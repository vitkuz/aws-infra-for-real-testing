"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const util_dynamodb_1 = require("@aws-sdk/util-dynamodb");
const aws_logger_1 = require("@vitkuz/aws-logger");
const opensearch_1 = require("@opensearch-project/opensearch");
const aws_opensearch_adapter_1 = require("@vitkuz/aws-opensearch-adapter");
const credential_provider_node_1 = require("@aws-sdk/credential-provider-node");
const aws_1 = require("@opensearch-project/opensearch/aws");
// Hardcoded index name as requested
const INDEX_NAME = 'vitkuz-search-sync-index';
const OPENSEARCH_ENDPOINT = process.env.OPENSEARCH_ENDPOINT;
const REGION = process.env.AWS_REGION || 'us-east-1'; // Default backup
if (!OPENSEARCH_ENDPOINT) {
    throw new Error('OPENSEARCH_ENDPOINT env var is missing');
}
const client = new opensearch_1.Client({
    ...(0, aws_1.AwsSigv4Signer)({
        region: REGION,
        service: 'es',
        getCredentials: () => (0, credential_provider_node_1.defaultProvider)()(),
    }),
    node: `https://${OPENSEARCH_ENDPOINT}`
});
exports.handler = (0, aws_logger_1.withLogger)(async (event, context) => {
    const logger = (0, aws_logger_1.getLogger)();
    if (!logger)
        throw new Error('Logger missing');
    const adapter = (0, aws_opensearch_adapter_1.createAdapter)({ client, logger });
    logger.info('Processing DynamoDB Stream for Search Sync', {
        data: {
            recordCount: event.Records.length,
            indexIs: INDEX_NAME
        }
    });
    for (const record of event.Records) {
        // Attempt to extract request ID if stored in the record (e.g. from the API insert)
        // This is a best-effort correlation
        let requestId;
        if (record.dynamodb?.NewImage) {
            const doc = (0, util_dynamodb_1.unmarshall)(record.dynamodb.NewImage);
            // If the item has a 'requestId' or similar field, we could use it.
            // Assuming standard field naming or just relying on Lambda context ID if not found.
            // If the user meant "extract custom request id key" from the *logger package*, I am using REQUEST_ID_KEY
            // to key it in the logger. I will check if 'x-request-id' exists in the document.
            if (doc['x-request-id']) {
                requestId = doc['x-request-id'];
            }
        }
        const childLogger = logger.child({
            ...(requestId ? { [aws_logger_1.REQUEST_ID_KEY]: requestId } : {}),
            eventName: record.eventName
        });
        try {
            if (record.eventName === 'INSERT' || record.eventName === 'MODIFY') {
                if (!record.dynamodb?.NewImage)
                    continue;
                // Unmarshall DynamoDB JSON to standard JSON
                const doc = (0, util_dynamodb_1.unmarshall)(record.dynamodb.NewImage);
                const id = doc.pk; // Assuming 'pk' is the ID
                if (!id) {
                    childLogger.warn('Skipping record without pk', { data: { record } });
                    continue;
                }
                await adapter.indexDocument({
                    index: INDEX_NAME,
                    id: id,
                    body: doc,
                    refresh: true // Forcing refresh for immediate consistency in tests, safe for low volume
                });
                childLogger.info('Indexed document', { data: { id, eventName: record.eventName } });
            }
            else if (record.eventName === 'REMOVE') {
                if (!record.dynamodb?.Keys)
                    continue;
                const keys = (0, util_dynamodb_1.unmarshall)(record.dynamodb.Keys);
                const id = keys.pk;
                if (!id) {
                    childLogger.warn('Skipping delete without pk', { data: { record } });
                    continue;
                }
                await adapter.deleteDocument({
                    index: INDEX_NAME,
                    id: id,
                    refresh: true
                });
                childLogger.info('Deleted document', { data: { id } });
            }
        }
        catch (error) {
            logger.error('Error processing record', { error: error instanceof Error ? error : String(error), data: { record } });
            // Should we throw to retry? Usually yes for reliability.
            // For this demo/test stack, logging might be sufficient, but rethrowing ensures DLQ/retry behavior.
            throw error;
        }
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSwwREFBb0Q7QUFFcEQsbURBQTJFO0FBQzNFLCtEQUF3RDtBQUN4RCwyRUFBK0Q7QUFDL0QsZ0ZBQW9FO0FBQ3BFLDREQUFvRTtBQUVwRSxvQ0FBb0M7QUFDcEMsTUFBTSxVQUFVLEdBQUcsMEJBQTBCLENBQUM7QUFDOUMsTUFBTSxtQkFBbUIsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDO0FBQzVELE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxJQUFJLFdBQVcsQ0FBQyxDQUFDLGlCQUFpQjtBQUV2RSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztJQUN2QixNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7QUFDOUQsQ0FBQztBQUVELE1BQU0sTUFBTSxHQUFHLElBQUksbUJBQU0sQ0FBQztJQUN0QixHQUFHLElBQUEsb0JBQWMsRUFBQztRQUNkLE1BQU0sRUFBRSxNQUFNO1FBQ2QsT0FBTyxFQUFFLElBQUk7UUFDYixjQUFjLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBQSwwQ0FBZSxHQUFFLEVBQUU7S0FDNUMsQ0FBQztJQUNGLElBQUksRUFBRSxXQUFXLG1CQUFtQixFQUFFO0NBQ3pDLENBQUMsQ0FBQztBQUVVLFFBQUEsT0FBTyxHQUFHLElBQUEsdUJBQVUsRUFBQyxLQUFLLEVBQUUsS0FBMEIsRUFBRSxPQUFnQixFQUFFLEVBQUU7SUFDckYsTUFBTSxNQUFNLEdBQUcsSUFBQSxzQkFBUyxHQUFFLENBQUM7SUFDM0IsSUFBSSxDQUFDLE1BQU07UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFFL0MsTUFBTSxPQUFPLEdBQUcsSUFBQSxzQ0FBYSxFQUFDLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFF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LEVBQUUsRUFBRTtvQkFDTixPQUFPLEVBQUUsSUFBSTtpQkFDaEIsQ0FBQyxDQUFDO2dCQUVILFdBQVcsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDM0QsQ0FBQztRQUNMLENBQUM7UUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1lBQ2IsTUFBTSxDQUFDLEtBQUssQ0FBQyx5QkFBeUIsRUFBRSxFQUFFLEtBQUssRUFBRSxLQUFLLFlBQVksS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBUyxDQUFDLENBQUM7WUFDNUgseURBQXlEO1lBQ3pELG9HQUFvRztZQUNwRyxNQUFNLEtBQUssQ0FBQztRQUNoQixDQUFDO0lBQ0wsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRHluYW1vREJTdHJlYW1FdmVudCwgQ29udGV4dCB9IGZyb20gJ2F3cy1sYW1iZGEnO1xuaW1wb3J0IHsgdW5tYXJzaGFsbCB9IGZyb20gJ0Bhd3Mtc2RrL3V0aWwtZHluYW1vZGInO1xuaW1wb3J0IHsgQXR0cmlidXRlVmFsdWUgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtZHluYW1vZGInO1xuaW1wb3J0IHsgd2l0aExvZ2dlciwgZ2V0TG9nZ2VyLCBSRVFVRVNUX0lEX0tFWSB9IGZyb20gJ0B2aXRrdXovYXdzLWxvZ2dlcic7XG5pbXBvcnQgeyBDbGllbnQgfSBmcm9tICdAb3BlbnNlYXJjaC1wcm9qZWN0L29wZW5zZWFyY2gnO1xuaW1wb3J0IHsgY3JlYXRlQWRhcHRlciB9IGZyb20gJ0B2aXRrdXovYXdzLW9wZW5zZWFyY2gtYWRhcHRlcic7XG5pbXBvcnQgeyBkZWZhdWx0UHJvdmlkZXIgfSBmcm9tICdAYXdzLXNkay9jcmVkZW50aWFsLXByb3ZpZGVyLW5vZGUnO1xuaW1wb3J0IHsgQXdzU2lndjRTaWduZXIgfSBmcm9tICdAb3BlbnNlYXJjaC1wcm9qZWN0L29wZW5zZWFyY2gvYXdzJztcblxuLy8gSGFyZGNvZGVkIGluZGV4IG5hbWUgYXMgcmVxdWVzdGVkXG5jb25zdCBJTkRFWF9OQU1FID0gJ3ZpdGt1ei1zZWFyY2gtc3luYy1pbmRleCc7XG5jb25zdCBPUEVOU0VBUkNIX0VORFBPSU5UID0gcHJvY2Vzcy5lbnYuT1BFTlNFQVJDSF9FTkRQT0lOVDtcbmNvbnN0IFJFR0lPTiA9IHByb2Nlc3MuZW52LkFXU19SRUdJT04gfHwgJ3VzLWVhc3QtMSc7IC8vIERlZmF1bHQgYmFja3VwXG5cbmlmICghT1BFTlNFQVJDSF9FTkRQT0lOVCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT1BFTlNFQVJDSF9FTkRQT0lOVCBlbnYgdmFyIGlzIG1pc3NpbmcnKTtcbn1cblxuY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCh7XG4gICAgLi4uQXdzU2lndjRTaWduZXIoe1xuICAgICAgICByZWdpb246IFJFR0lPTixcbiAgICAgICAgc2VydmljZTogJ2VzJyxcbiAgICAgICAgZ2V0Q3JlZGVudGlhbHM6ICgpID0+IGRlZmF1bHRQcm92aWRlcigpKCksXG4gICAgfSksXG4gICAgbm9kZTogYGh0dHBzOi8vJHtPUEVOU0VBUkNIX0VORFBPSU5UfWBcbn0pO1xuXG5leHBvcnQgY29uc3QgaGFuZGxlciA9IHdpdGhMb2dnZXIoYXN5bmMgKGV2ZW50OiBEeW5hbW9EQlN0cmVhbUV2ZW50LCBjb250ZXh0OiBDb250ZXh0KSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKCk7XG4gICAgaWYgKCFsb2dnZXIpIHRocm93IG5ldyBFcnJvcignTG9nZ2VyIG1pc3NpbmcnKTtcblxuICAgIGNvbnN0IGFkYXB0ZXIgPSBjcmVhdGVBZGFwdGVyKHsgY2xpZW50LCBsb2dnZXIgfSk7XG5cbiAgICBsb2dnZXIuaW5mbygnUHJvY2Vzc2luZyBEeW5hbW9EQiBTdHJlYW0gZm9yIFNlYXJjaCBTeW5jJywge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICByZWNvcmRDb3VudDogZXZlbnQuUmVjb3Jkcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleElzOiBJTkRFWF9OQU1FXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIGV2ZW50LlJlY29yZHMpIHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBleHRyYWN0IHJlcXVlc3QgSUQgaWYgc3RvcmVkIGluIHRoZSByZWNvcmQgKGUuZy4gZnJvbSB0aGUgQVBJIGluc2VydClcbiAgICAgICAgLy8gVGhpcyBpcyBhIGJlc3QtZWZmb3J0IGNvcnJlbGF0aW9uXG4gICAgICAgIGxldCByZXF1ZXN0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJlY29yZC5keW5hbW9kYj8uTmV3SW1hZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IHVubWFyc2hhbGwocmVjb3JkLmR5bmFtb2RiLk5ld0ltYWdlIGFzIHsgW2tleTogc3RyaW5nXTogQXR0cmlidXRlVmFsdWUgfSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgaXRlbSBoYXMgYSAncmVxdWVzdElkJyBvciBzaW1pbGFyIGZpZWxkLCB3ZSBjb3VsZCB1c2UgaXQuXG4gICAgICAgICAgICAvLyBBc3N1bWluZyBzdGFuZGFyZCBmaWVsZCBuYW1pbmcgb3IganVzdCByZWx5aW5nIG9uIExhbWJkYSBjb250ZXh0IElEIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIG1lYW50IFwiZXh0cmFjdCBjdXN0b20gcmVxdWVzdCBpZCBrZXlcIiBmcm9tIHRoZSAqbG9nZ2VyIHBhY2thZ2UqLCBJIGFtIHVzaW5nIFJFUVVFU1RfSURfS0VZXG4gICAgICAgICAgICAvLyB0byBrZXkgaXQgaW4gdGhlIGxvZ2dlci4gSSB3aWxsIGNoZWNrIGlmICd4LXJlcXVlc3QtaWQnIGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICBpZiAoZG9jWyd4LXJlcXVlc3QtaWQnXSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJZCA9IGRvY1sneC1yZXF1ZXN0LWlkJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNvbnN0IGNoaWxkTG9nZ2VyID0gbG9nZ2VyLmNoaWxkKHtcbiAgICAgICAgICAgIC4uLihyZXF1ZXN0SWQgPyB7IFtSRVFVRVNUX0lEX0tFWV06IHJlcXVlc3RJZCB9IDoge30pLFxuICAgICAgICAgICAgZXZlbnROYW1lOiByZWNvcmQuZXZlbnROYW1lXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocmVjb3JkLmV2ZW50TmFtZSA9PT0gJ0lOU0VSVCcgfHwgcmVjb3JkLmV2ZW50TmFtZSA9PT0gJ01PRElGWScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY29yZC5keW5hbW9kYj8uTmV3SW1hZ2UpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gVW5tYXJzaGFsbCBEeW5hbW9EQiBKU09OIHRvIHN0YW5kYXJkIEpTT05cbiAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSB1bm1hcnNoYWxsKHJlY29yZC5keW5hbW9kYi5OZXdJbWFnZSBhcyB7IFtrZXk6IHN0cmluZ106IEF0dHJpYnV0ZVZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZG9jLnBrOyAvLyBBc3N1bWluZyAncGsnIGlzIHRoZSBJRFxuXG4gICAgICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZExvZ2dlci53YXJuKCdTa2lwcGluZyByZWNvcmQgd2l0aG91dCBwaycsIHsgZGF0YTogeyByZWNvcmQgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRhcHRlci5pbmRleERvY3VtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IElOREVYX05BTUUsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogZG9jLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoOiB0cnVlIC8vIEZvcmNpbmcgcmVmcmVzaCBmb3IgaW1tZWRpYXRlIGNvbnNpc3RlbmN5IGluIHRlc3RzLCBzYWZlIGZvciBsb3cgdm9sdW1lXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjaGlsZExvZ2dlci5pbmZvKCdJbmRleGVkIGRvY3VtZW50JywgeyBkYXRhOiB7IGlkLCBldmVudE5hbWU6IHJlY29yZC5ldmVudE5hbWUgfSB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQuZXZlbnROYW1lID09PSAnUkVNT1ZFJykge1xuICAgICAgICAgICAgICAgIGlmICghcmVjb3JkLmR5bmFtb2RiPy5LZXlzKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSB1bm1hcnNoYWxsKHJlY29yZC5keW5hbW9kYi5LZXlzIGFzIHsgW2tleTogc3RyaW5nXTogQXR0cmlidXRlVmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBrZXlzLnBrO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZExvZ2dlci53YXJuKCdTa2lwcGluZyBkZWxldGUgd2l0aG91dCBwaycsIHsgZGF0YTogeyByZWNvcmQgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXdhaXQgYWRhcHRlci5kZWxldGVEb2N1bWVudCh7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBJTkRFWF9OQU1FLFxuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHJlZnJlc2g6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNoaWxkTG9nZ2VyLmluZm8oJ0RlbGV0ZWQgZG9jdW1lbnQnLCB7IGRhdGE6IHsgaWQgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyByZWNvcmQnLCB7IGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBTdHJpbmcoZXJyb3IpLCBkYXRhOiB7IHJlY29yZCB9IH0gYXMgYW55KTtcbiAgICAgICAgICAgIC8vIFNob3VsZCB3ZSB0aHJvdyB0byByZXRyeT8gVXN1YWxseSB5ZXMgZm9yIHJlbGlhYmlsaXR5LlxuICAgICAgICAgICAgLy8gRm9yIHRoaXMgZGVtby90ZXN0IHN0YWNrLCBsb2dnaW5nIG1pZ2h0IGJlIHN1ZmZpY2llbnQsIGJ1dCByZXRocm93aW5nIGVuc3VyZXMgRExRL3JldHJ5IGJlaGF2aW9yLlxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiJdfQ==